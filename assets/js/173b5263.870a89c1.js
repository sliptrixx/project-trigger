"use strict";(self.webpackChunkproject_trigger=self.webpackChunkproject_trigger||[]).push([[635],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var i=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=i.createContext({}),c=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return i.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=o,u=m["".concat(s,".").concat(d)]||m[d]||p[d]||a;return n?i.createElement(u,r(r({ref:t},h),{},{components:n})):i.createElement(u,r({ref:t},h))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var c=2;c<a;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8783:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var i=n(7462),o=(n(7294),n(3905));const a={sidebar_position:6},r="Tutorial: Basic Enemy",l={unversionedId:"Tutorials/basic_enemy",id:"Tutorials/basic_enemy",title:"Tutorial: Basic Enemy",description:"In this section we will go over how we can create a basic enemy that can move left and right and shoot bullets at a constant rate. We will reuse a lot of code we have written in the previous sections and learn how powerful modular single responsibility code can be.",source:"@site/docs/Tutorials/6_basic_enemy.md",sourceDirName:"Tutorials",slug:"/Tutorials/basic_enemy",permalink:"/project-trigger/docs/Tutorials/basic_enemy",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Tutorial: Health",permalink:"/project-trigger/docs/Tutorials/health"}},s={},c=[{value:"Getting Started",id:"getting-started",level:2},{value:"EnemyAI.cs",id:"enemyaics",level:2},{value:"Blaster",id:"blaster",level:3},{value:"Shooting",id:"shooting",level:3},{value:"Movement",id:"movement",level:3},{value:"Final Script",id:"final-script",level:3},{value:"Bonus",id:"bonus",level:2},{value:"Orientation Agnostic Movement",id:"orientation-agnostic-movement",level:3},{value:"Final Thoughts",id:"final-thoughts",level:2}],h={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"tutorial-basic-enemy"},"Tutorial: Basic Enemy"),(0,o.kt)("p",null,"In this section we will go over how we can create a basic enemy that can move left and right and shoot bullets at a constant rate. We will reuse a lot of code we have written in the previous sections and learn how powerful modular single responsibility code can be."),(0,o.kt)("h2",{id:"getting-started"},"Getting Started"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First, lets convert our ",(0,o.kt)("inlineCode",{parentName:"li"},"Meteor")," gameobject into a prefab by dragging it into the ",(0,o.kt)("em",{parentName:"li"},'"Prefabs"')," folder"),(0,o.kt)("li",{parentName:"ul"},"Next, lets create a new GameObject called ",(0,o.kt)("inlineCode",{parentName:"li"},"Enemy")," and set it up similar to the ",(0,o.kt)("inlineCode",{parentName:"li"},"Meteor")," GameObject",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Add a sprite renderer and set the sprite to ",(0,o.kt)("inlineCode",{parentName:"li"},"EnemyRed5")),(0,o.kt)("li",{parentName:"ul"},"Add a ",(0,o.kt)("inlineCode",{parentName:"li"},"Rigidbody2D")," component and set the gravity scale to 0"),(0,o.kt)("li",{parentName:"ul"},"Add a ",(0,o.kt)("inlineCode",{parentName:"li"},"CircleCollider2D")," component and set the radius to 0.485"),(0,o.kt)("li",{parentName:"ul"},"Add a ",(0,o.kt)("inlineCode",{parentName:"li"},"Health")," component and set the hp to 3"),(0,o.kt)("li",{parentName:"ul"},"Add a ",(0,o.kt)("inlineCode",{parentName:"li"},"Blaster")," component and add the appropriate bullet prefab"))),(0,o.kt)("li",{parentName:"ul"},"Rotate the ",(0,o.kt)("inlineCode",{parentName:"li"},"Enemy")," GameObject 180 degrees on the Z axis")),(0,o.kt)("p",null,"Notice how we are reusing the ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," components we created in the previous sections. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Health")," script can be damaged and destroyed by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Bullet")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," script can shoot bullets from a specified offset. Furthermore, the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component uses a ",(0,o.kt)("inlineCode",{parentName:"p"},"Bullet")," prefab with a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"Projectile")," script we previously created."),(0,o.kt)("p",null,"These scripts are not local to the player, but can be used by any GameObject, which is pretty cool. This is the power of modular single responsibility code. We can reuse the same code for different purposes."),(0,o.kt)("h2",{id:"enemyaics"},"EnemyAI.cs"),(0,o.kt)("p",null,"Now lets create a new script called ",(0,o.kt)("inlineCode",{parentName:"p"},"EnemyAI.cs")," and add it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Enemy")," GameObject that will be responsible for controlling when the enemy shoots and its movement."),(0,o.kt)("h3",{id:"blaster"},"Blaster"),(0,o.kt)("p",null,"Let's start with the shooting. First, we need a reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component so we can shoot bullets. We can get a reference to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"protected Blaster blaster;\n\nvoid Start()\n{\n    blaster = GetComponent<Blaster>();\n}\n")),(0,o.kt)("p",null,"A really useful attribute we can use is the ",(0,o.kt)("inlineCode",{parentName:"p"},"RequireComponent")," attribute. This attribute will force a GameObject to have the specified component, when this component is attached. First have a look at what it looks like."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"[RequireComponent(typeof(Blaster))]\npublic class EnemyAI : MonoBehaviour\n{\n    // ...\n}\n")),(0,o.kt)("p",null,"Here, we are defining that the ",(0,o.kt)("inlineCode",{parentName:"p"},"EnemyAI")," component requires the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component to function. So, when you add an EnemyAI component to a GameObject, it will automatically add a ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component to the GameObject. This is useful because we don't have to worry about adding the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component to the GameObject, and we can just assume that the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component is there. Another benefit of this is that if we accidentally try to remove the ",(0,o.kt)("inlineCode",{parentName:"p"},"Blaster")," component from a GameObject with the ",(0,o.kt)("inlineCode",{parentName:"p"},"EnemyAI")," component, Unity will prevent us from doing so."),(0,o.kt)("h3",{id:"shooting"},"Shooting"),(0,o.kt)("p",null,"We want the enemy to fire projectile at a constant rate, say every x seconds. We can define this rate as ",(0,o.kt)("inlineCode",{parentName:"p"},"fireRate")," and set it to 1 second. We can use another variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"fireTimer")," to keep track of how much time has elapsed since the last shot. As soon as the ",(0,o.kt)("inlineCode",{parentName:"p"},"fireTimer")," reaches the ",(0,o.kt)("inlineCode",{parentName:"p"},"fireRate")," we can shoot a bullet and reset the ",(0,o.kt)("inlineCode",{parentName:"p"},"fireTimer")," to 0."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"// how often the enemy shoots\n[SerializeField] protected float fireRate = 1.0f;\n\n// variable to keep track of how many seconds have elapsed since the last shot\nprotected float fireTimer = 0;\n\nvoid Update()\n{\n    // increment the timer\n    fireTimer += Time.deltaTime;\n\n    // if the timer has elapsed, shoot a bullet and reset the timer\n    if(fireTimer >= fireRate)\n    {\n        blaster.Shoot();\n        fireTimer = 0;\n    }\n}\n")),(0,o.kt)("p",null,"Now we can test our game and see if the enemy is shooting bullets at a constant rate. Try changing the ",(0,o.kt)("inlineCode",{parentName:"p"},"fireRate")," value in the inspector to see how it affects the game."),(0,o.kt)("h3",{id:"movement"},"Movement"),(0,o.kt)("p",null,"The enemy now shoots bullets at a constant rate, but it static and kind of boring. Let's make it a bit more interesting by making move left and right. We must define a variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"moveSpeed")," that determines how fast the enemy will move. We also need to define a variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"WiggleRoom")," (probably there's a better name to describe this functionality) that defines how far the enemy can move left and right from its initial position. Finally, we need a variable call ",(0,o.kt)("inlineCode",{parentName:"p"},"MoveRight")," that determines if the enemy is moving right or left."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"// how fast the enemy moves\n[SerializeField] protected float moveSpeed = 1.0f;\n\n// how far the enemy can move left and right from its initial position\n[SerializeField] protected float WiggleRoom = 1.0f;\n\n// determines if the enemy is moving right or left\n[SerializeField] protected bool MoveRight = true;\n")),(0,o.kt)("p",null,"It might seem unnecessary to add the ",(0,o.kt)("inlineCode",{parentName:"p"},"SerializeField")," attribute to it, but by making the ",(0,o.kt)("inlineCode",{parentName:"p"},"MoveRight")," variable editable in the editor, we can change the start direction of the enemy."),(0,o.kt)("p",null,"In order to move the enemy from the start position, we need to first store and cache the initial position of the enemy. We can do this in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"// the position that anchors the enemy\nprotected Vector3 anchor;\n\nvoid Start()\n{\n    // cache the initial position of the enemy\n    anchor = transform.position;\n}\n")),(0,o.kt)("p",null,'Now in the update loop we can move the enemy in the expected direction. I\'m going to do it in a "dumb" way, but in the bonus section we will we will make it a bit more interesting.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"void Update()\n{\n    // the vector3 direction in which the enemy should move\n    Vector3 direction = (MoveRight) ? Vector3.right : -Vector3.right;\n\n    // apply the movement\n    transform.position += direction * moveSpeed * Time.deltaTime;\n\n    // switch direction of travel once the enemy has reached the edge of the wiggle room\n    if ((MoveRight && transform.position.x > anchor.x + WiggleRoom / 2) || (!MoveRight && transform.position.x < anchor.x WiggleRoom / 2))\n    {\n        MoveRight = !MoveRight;\n    }\n}\n")),(0,o.kt)("p",null,"Now we test this feature in the game and see if the enemy is moving left to right and right to left. Try changing and experimenting with the exposed values in the inspector and see how it affects the game."),(0,o.kt)("h3",{id:"final-script"},"Final Script"),(0,o.kt)("p",null,"Here is the final script for the ",(0,o.kt)("inlineCode",{parentName:"p"},"EnemyAI")," component."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'using UnityEngine;\n\n[RequireComponent(typeof(Blaster))]\npublic class EnemyAI : MonoBehaviour\n{\n    [Tooltip("How frequently should the enemy fire a projectile (given in seconds)")]\n    [SerializeField] protected float fireRate = 1;\n\n    [Header("Simple movement")]\n    [Tooltip("How fast should the enemy travel in terms units/seconds")]\n    [SerializeField] protected float moveSpeed = 1;\n\n    [Tooltip("How far should the the enemy move")]\n    [SerializeField] protected float WiggleRoom = 1;\n\n    [Tooltip("The direction in which the enemy AI should currently move")]\n    [SerializeField] protected bool MoveRight = true;\n\n    // A private reference to the blaster that the enemy can shoot from\n    protected Blaster blaster;\n\n    // this variable is used to track how many seconds have elapsed since last fired\n    protected float fireTimer = 0;\n\n    // the position that anchor\'s the enemy\n    protected Vector3 anchor;\n\n    void Start()\n    {\n        // since we are using the RequireComponent attribute, we are guaranteed to have a blaster\n        blaster = GetComponent<Blaster>();\n\n        // set the anchor position so that the enemy can move left and right relative to it\n        anchor = transform.position;\n    }\n\n    private void Update()\n    {\n        // increment the timer\n        fireTimer += Time.deltaTime;\n\n        // if the timer has elapsed, shoot from the blaster and reset the timer\n        if(fireTimer >= fireRate)\n        {\n            blaster.Shoot();\n            fireTimer = 0;\n        }\n\n        // move the player in the expected direction\n        Vector3 move = MoveRight ? Vector3.right : -Vector3.right;\n        transform.position += move * Time.deltaTime * moveSpeed;\n\n        // do the check to toggle the direction once they have travelled pass the bounds\n        if ((MoveRight && transform.position.x > anchor.x + WiggleRoom / 2) || (!MoveRight && transform.position.x < anchor.x - WiggleRoom / 2))\n        {\n            MoveRight = !MoveRight;\n        }\n    }\n}\n')),(0,o.kt)("h2",{id:"bonus"},"Bonus"),(0,o.kt)("h3",{id:"orientation-agnostic-movement"},"Orientation Agnostic Movement"),(0,o.kt)("p",null,"The enemy moves left and right, but there's an issue. Try rotating the player and see what happens. The enemy will continue moving left and right in the world space and not in respect to its orientation. If that's your desired behavior, then you can skip this section. However, if you want the enemy to move left and right in respect to its orientation, then keep reading."),(0,o.kt)("p",null,"We can solve this by using the local transform right vector instead of the world space right vector. And for the condition to switch direction of travel, we can calculate the distance between the enemy's current position and the anchor position and compare it to the wiggle room."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"// the direction to move\nVector3 direction = (MoveRight) ? transform.right : -transform.right;\ntransform.position += direction * moveSpeed * Time.deltaTime;\n\n// switch direction of travel once the enemy has reached the edge of the wiggle room\nif(Vector3.Distance(anchor, transform.position) > WiggleRoom / 2) \n{\n    MoveRight = !MoveRight;\n}\n")),(0,o.kt)("h2",{id:"final-thoughts"},"Final Thoughts"),(0,o.kt)("p",null,"In this tutorial, we learned how to create a very simple enemy AI that uses a blaster to shoot at the player at a constant fire rate while moving left and right. It's a very much possible to split this script into multiple components, say seperating the movement and the shooting functionality. However, for the sake of simplicity, I decided to keep it all in one script."),(0,o.kt)("p",null,"More over, I plan on upgrading the Enemy AI script to use a finite state machine, so the simpler the script is, the less work to scrap and rewrite. The content on the finite state machine will be covered in a future tutorial in the advanced section of the series."))}p.isMDXComponent=!0}}]);