"use strict";(self.webpackChunkproject_trigger=self.webpackChunkproject_trigger||[]).push([[734],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(a),m=r,p=h["".concat(s,".").concat(m)]||h[m]||d[m]||i;return a?n.createElement(p,o(o({ref:t},c),{},{components:a})):n.createElement(p,o({ref:t},c))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:r,o[1]=l;for(var u=2;u<i;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(6010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>S});var n=a(7462),r=a(7294),i=a(6010),o=a(2466),l=a(6550),s=a(1980),u=a(7392),c=a(12);function h(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??h(a);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function m(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:a}=e;const n=(0,l.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function f(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,i=d(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!m({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[s,u]=p({queryString:a,groupId:n}),[h,f]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,c.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:n}),g=(()=>{const e=s??h;return m({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!m({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,i]),tabValues:i}}var g=a(2389);const k="tabList__CuJ",b="tabItem_LNqP";function v(e){let{className:t,block:a,selectedValue:l,selectValue:s,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:h}=(0,o.o5)(),d=e=>{const t=e.currentTarget,a=c.indexOf(t),n=u[a].value;n!==l&&(h(t),s(n))},m=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=c.indexOf(e.currentTarget)+1;t=c[a]??c[0];break}case"ArrowLeft":{const a=c.indexOf(e.currentTarget)-1;t=c[a]??c[c.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t)},u.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>c.push(e),onKeyDown:m,onClick:d},o,{className:(0,i.Z)("tabs__item",b,o?.className,{"tabs__item--active":l===t})}),a??t)})))}function y(e){let{lazy:t,children:a,selectedValue:n}=e;if(a=Array.isArray(a)?a:[a],t){const e=a.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function w(e){const t=f(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",k)},r.createElement(v,(0,n.Z)({},e,t)),r.createElement(y,(0,n.Z)({},e,t)))}function S(e){const t=(0,g.Z)();return r.createElement(w,(0,n.Z)({key:String(t)},e))}},3238:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>m,frontMatter:()=>l,metadata:()=>u,toc:()=>h});var n=a(7462),r=(a(7294),a(3905)),i=a(4866),o=a(5162);const l={sidebar_position:13},s="Tutorial: Screen Shake",u={unversionedId:"Advanced Tutorials/ScreenShake",id:"Advanced Tutorials/ScreenShake",title:"Tutorial: Screen Shake",description:"In this short tutorial, we will discuss how we can use a CameraShake script to shake the camera when an event occurs. This is useful in games to add a bit of excitement to them. We will be primarily looking at an implementation technique that works for a fixed 2D camera. This is not the only way to implement screen shake, but it is a simple and effective way to do it.",source:"@site/docs/Advanced Tutorials/13_ScreenShake.md",sourceDirName:"Advanced Tutorials",slug:"/Advanced Tutorials/ScreenShake",permalink:"/project-trigger/docs/Advanced Tutorials/ScreenShake",draft:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Tutorial: Bounds",permalink:"/project-trigger/docs/Advanced Tutorials/bounds"},next:{title:"Tutorial: Particle Effects",permalink:"/project-trigger/docs/Advanced Tutorials/ParticleEffects"}},c={},h=[{value:"ScreenShake.cs",id:"screenshakecs",level:2},{value:"Shaking the camera",id:"shaking-the-camera",level:3},{value:"Using the CameraShake",id:"using-the-camerashake",level:3},{value:"Attenuating the shake",id:"attenuating-the-shake",level:3},{value:"Conculsion",id:"conculsion",level:2},{value:"Final Scripts",id:"final-scripts",level:2}],d={toc:h};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tutorial-screen-shake"},"Tutorial: Screen Shake"),(0,r.kt)("p",null,"In this short tutorial, we will discuss how we can use a ",(0,r.kt)("inlineCode",{parentName:"p"},"CameraShake")," script to shake the camera when an event occurs. This is useful in games to add a bit of excitement to them. We will be primarily looking at an implementation technique that works for a fixed 2D camera. This is not the only way to implement screen shake, but it is a simple and effective way to do it."),(0,r.kt)("h2",{id:"screenshakecs"},"ScreenShake.cs"),(0,r.kt)("p",null,"Let's start by creating and attaching a new script called ",(0,r.kt)("inlineCode",{parentName:"p"},"CameraShake")," and attach it to the main camera. We will need to store the original position of the camera so that we can apply an offset to it. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// the original position of the camera\nVector3 origin;\n\nvoid Start()\n{\n    origin = transform.position; // assuming that the script is attached to the camera\n}\n")),(0,r.kt)("p",null,"We need to create a function that will start the camera shake. The actual shake will be done in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Update")," function, but we need to store the duration and magnitude of the shake so that we can use it in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Update")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// how long the camera shake should last?\nfloat duration = 0;\n\n// how strong the camera shake should be?\nfloat magnitude = 0;\n\npublic void Shake(float duration, float magnitude)\n{\n    this.duration = duration;\n    this.magnitude = magnitude;\n}\n")),(0,r.kt)("h3",{id:"shaking-the-camera"},"Shaking the camera"),(0,r.kt)("p",null,"The magnitude of the shake is the maximum distance that the camera can move from the original position. We can pick a random float value between 0 and the magnitude and apply that as the offset to the camera on the ",(0,r.kt)("inlineCode",{parentName:"p"},"x-axis. We can then use this "),"x",(0,r.kt)("inlineCode",{parentName:"p"},"value and the"),"magnitude",(0,r.kt)("inlineCode",{parentName:"p"},"to calculate the"),"y` value using the Pythagorean theorem. This will give us a random offset that's part of the circle with the radius of the magnitude."),(0,r.kt)("p",null,"$$y = sqrt(\\sqrt(magnitude^2-x^2))$$"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"void Update()\n{\n    // skip if the duration is 0\n    if (duration <= 0) { return; }\n\n    // pick a random value that's between 0 and the magnitude as the x offset\n    float x = Random.Range(0, magnitude);\n\n    // calculate the y offset so that's it in a circle with a radius of magnitude\n    float y = Mathf.Sqrt(magnitude * magnitude - x * x);\n\n    // apply the offset to the camera\n    transform.position = origin + new Vector3(x, y, 0);\n\n    // tick the timer down\n    duration -= Time.deltaTime;\n}\n")),(0,r.kt)("p",null,"The other thing we need to do is to determine the axis of the shake. I just picked a scheme where the shake on the horizontal axis is flip-flopped every frame and the shake on the vertical axis is random. There's probably a much better way to do this, but this is just a simple implementation that doesn't look too bad."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"bool moveRight = false;\n\nvoid Update()\n{\n    // ... calculate x and y\n\n    // pick the positive/negative axises - x is based on moveRight - y is random\n    x *= moveRight ? 1 : -1;\n    y *= (Random.Range(0.0f, 1.0f) < 0.5f) ? 1 : -1;\n\n    // apply the offset to the camera\n    transform.position = origin + new Vector3(x, y, 0);\n\n    // end of tick updates\n    moveRight = !moveRight;\n    duration -= Time.deltaTime;\n}\n")),(0,r.kt)("h3",{id:"using-the-camerashake"},"Using the CameraShake"),(0,r.kt)("p",null,"We can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"CameraShake")," script to apply a shake to the camera when an entity takes damage. This has to be implemented in the ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," script"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"CameraShake cameraShake;\n\nvoid Start()\n{\n    cameraShake = FindObjectOfType<CameraShake>();\n}\n\npublic void ApplyDamage(int damage)\n{\n    hp -= damage;\n\n    // apply camera shake as a feedback\n    cameraShake.Shake(0.25f, 0.2f);\n\n    if (hp <= 0)\n    {\n        // audio code...\n\n        // Apply a larger camera shake on death\n        cameraShake.Shake(0.4f, 0.4f);\n    }\n}\n")),(0,r.kt)("h3",{id:"attenuating-the-shake"},"Attenuating the shake"),(0,r.kt)("p",null,"The shake is constant right now, but we can make it attenuated and it's magnitude will decrease to 0 over time. We can do this by introducing a new variable called ",(0,r.kt)("inlineCode",{parentName:"p"},"attenuation")," which will represent the rate at which the magnitude will decrease every second. We can then decrease the magnitude by this calculated ",(0,r.kt)("inlineCode",{parentName:"p"},"attenuation")," value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"void Update()\n{\n    // end of tick updates\n    magnitude -= attenuation * Time.deltaTime;\n}\n\npublic void Shake(float duration, float magnitude)\n{\n    this.duration = duration;\n    this.magnitude = magnitude;\n\n    // calculate the attenuation\n    attenuation = magnitude / duration;\n}\n")),(0,r.kt)("h2",{id:"conculsion"},"Conculsion"),(0,r.kt)("p",null,"This tutorial covers a very simple implementation of screen shake with some basic attenuation. However, there are many different ways to do it and make it better. You may try and lerp from the current offset to the new expected offset to make it smoother. You may return it back to its origin after the shake is done. You may calculate the magnitude of the shake from the source based on the distance from the player."),(0,r.kt)("p",null,"Furthermore, all of the techniques discussed seem very simple for a 2D game with a fixed camera. However, once the camera starts moving, the camera's position is no longer the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform.position")," of the camera. You will need to store that position in a different variable and use that to set the ",(0,r.kt)("inlineCode",{parentName:"p"},"transform.position")," and apply the camera shake. It becomes a bit more complicated, but it's still doable."),(0,r.kt)("h2",{id:"final-scripts"},"Final Scripts"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"CameraShake.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using UnityEngine;\n\npublic class CameraShake : MonoBehaviour\n{\n    // how long the shake should be?\n    float duration = 0;\n\n    // how strong should the shake be?\n    float magnitude;\n\n    // attenuation per second\n    float attenuation;\n\n    // the origin where the object starts\n    Vector3 origin;\n\n    // flip flop tracker\n    bool moveRight = false;\n\n    void Start()\n    {\n        origin = transform.position;\n    }\n\n    void Update()\n    {\n        // if the duration is less than 0, there's nothing to shake\n        if(duration <= 0) { return; }\n\n        // pick a random value that's between 0 and the magnitude as the x offset\n        float x = Random.Range(0, magnitude);\n\n        // calculate the y offset so that's it in a circle with a radius of magnitude\n        float y = Mathf.Sqrt(magnitude * magnitude - x * x);\n\n        // pick the positive/negative axises - x is based on moveRight - y is random\n        x *= moveRight ? 1 : -1;\n        y *= (Random.Range(0.0f, 1.0f) < 0.5f) ? 1 : -1;\n\n        // appply the offset\n        transform.position = origin + new Vector3(x, y, 0);\n\n        // tick down the duration and update magnitude based on the calculated attenuation\n        duration -= Time.deltaTime;\n        magnitude -= attenuation * Time.deltaTime;\n        moveRight = !moveRight;\n    }\n\n    // Shake the camera with the given magnitude for the specified duration\n    public void Shake(float duration, float magnitude)\n    {\n        this.duration = duration;\n        this.magnitude = magnitude;\n        attenuation = magnitude / duration;\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"Health.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using UnityEngine;\n\npublic class Health : MonoBehaviour\n{\n    [SerializeField] protected int hp = 1;\n\n    CameraShake cameraShake = null;\n\n    void Start()\n    {\n        cameraShake = FindObjectOfType<CameraShake>();\n    }\n\n    // Apply damage to the object\n    public void ApplyDamage(int damage)\n    {\n        hp -= damage;\n\n        // apply camera shake as a feedback\n        cameraShake.Shake(0.25f, 0.2f);\n\n        // if the health drops below zero destroy the object\n        if (hp <= 0)\n        {\n            // play the explosion sound effect before destroying the object\n            var audioManager = FindObjectOfType<AudioManager>();\n            audioManager?.PlayExplosion(transform.position);\n\n            // Apply a larger camera shake when the enemy is killed\n            cameraShake.Shake(0.4f, 0.4f);\n\n            // destroy the object\n            Destroy(gameObject);\n        }\n    }\n\n    // Apply heals to the object\n    public void ApplyHeals(int heals)\n    {\n        // basically reverse damage\n        ApplyDamage(-heals);\n    }\n\n    // Get the health from the health component\n    public int GetHP() \n    {\n        return hp;\n    }\n}\n")))))}m.isMDXComponent=!0}}]);