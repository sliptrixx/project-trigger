"use strict";(self.webpackChunkproject_trigger=self.webpackChunkproject_trigger||[]).push([[718],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>f});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(a),h=r,f=p["".concat(s,".").concat(h)]||p[h]||d[h]||i;return a?n.createElement(f,o(o({ref:t},u),{},{components:a})):n.createElement(f,o({ref:t},u))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=a[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},5162:(e,t,a)=>{a.d(t,{Z:()=>o});var n=a(7294),r=a(6010);const i="tabItem_Ymn6";function o(e){let{children:t,hidden:a,className:o}=e;return n.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,o),hidden:a},t)}},4866:(e,t,a)=>{a.d(t,{Z:()=>E});var n=a(7462),r=a(7294),i=a(6010),o=a(2466),l=a(6550),s=a(1980),c=a(7392),u=a(12);function p(e){return function(e){return r.Children.map(e,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:a,attributes:n,default:r}}=e;return{value:t,label:a,attributes:n,default:r}}))}function d(e){const{values:t,children:a}=e;return(0,r.useMemo)((()=>{const e=t??p(a);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,a])}function h(e){let{value:t,tabValues:a}=e;return a.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:a}=e;const n=(0,l.k6)(),i=function(e){let{queryString:t=!1,groupId:a}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!a)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return a??null}({queryString:t,groupId:a});return[(0,s._X)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(n.location.search);t.set(i,e),n.replace({...n.location,search:t.toString()})}),[i,n])]}function m(e){const{defaultValue:t,queryString:a=!1,groupId:n}=e,i=d(e),[o,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${a.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=a.find((e=>e.default))??a[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:i}))),[s,c]=f({queryString:a,groupId:n}),[p,m]=function(e){let{groupId:t}=e;const a=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,i]=(0,u.Nk)(a);return[n,(0,r.useCallback)((e=>{a&&i.set(e)}),[a,i])]}({groupId:n}),g=(()=>{const e=s??p;return h({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!h({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),m(e)}),[c,m,i]),tabValues:i}}var g=a(2389);const b="tabList__CuJ",y="tabItem_LNqP";function k(e){let{className:t,block:a,selectedValue:l,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:p}=(0,o.o5)(),d=e=>{const t=e.currentTarget,a=u.indexOf(t),n=c[a].value;n!==l&&(p(t),s(n))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const a=u.indexOf(e.currentTarget)+1;t=u[a]??u[0];break}case"ArrowLeft":{const a=u.indexOf(e.currentTarget)-1;t=u[a]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":a},t)},c.map((e=>{let{value:t,label:a,attributes:o}=e;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>u.push(e),onKeyDown:h,onClick:d},o,{className:(0,i.Z)("tabs__item",y,o?.className,{"tabs__item--active":l===t})}),a??t)})))}function v(e){let{lazy:t,children:a,selectedValue:n}=e;if(a=Array.isArray(a)?a:[a],t){const e=a.find((e=>e.props.value===n));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function w(e){const t=m(e);return r.createElement("div",{className:(0,i.Z)("tabs-container",b)},r.createElement(k,(0,n.Z)({},e,t)),r.createElement(v,(0,n.Z)({},e,t)))}function E(e){const t=(0,g.Z)();return r.createElement(w,(0,n.Z)({key:String(t)},e))}},2247:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>u,contentTitle:()=>s,default:()=>h,frontMatter:()=>l,metadata:()=>c,toc:()=>p});var n=a(7462),r=(a(7294),a(3905)),i=a(4866),o=a(5162);const l={sidebar_position:14},s="Tutorial: Particle Effects",c={unversionedId:"Advanced Tutorials/ParticleEffects",id:"Advanced Tutorials/ParticleEffects",title:"Tutorial: Particle Effects",description:"In this tutorial, we will have a brief look at the particle system in Unity. The particle system is a very powerful tool that can be used to configure and create a wide variety of effects that can add a lot of polish to your game. In this tutorial, we will be looking at how we can manipulate the particle system to create a simple explosion effect that we can use when an enemy dies.",source:"@site/docs/Advanced Tutorials/14_ParticleEffects.md",sourceDirName:"Advanced Tutorials",slug:"/Advanced Tutorials/ParticleEffects",permalink:"/project-trigger/docs/Advanced Tutorials/ParticleEffects",draft:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"Tutorial: Screen Shake",permalink:"/project-trigger/docs/Advanced Tutorials/ScreenShake"},next:{title:"Tutorial: Player Movement",permalink:"/project-trigger/docs/Basic Tutorials/player_movement"}},u={},p=[{value:"The Explosion Effect",id:"the-explosion-effect",level:2},{value:"Using the Effect",id:"using-the-effect",level:2},{value:"Self Destruct",id:"self-destruct",level:3},{value:"Conclusion",id:"conclusion",level:2},{value:"Next Steps",id:"next-steps",level:3},{value:"Final Scripts",id:"final-scripts",level:2}],d={toc:p};function h(e){let{components:t,...l}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"tutorial-particle-effects"},"Tutorial: Particle Effects"),(0,r.kt)("p",null,"In this tutorial, we will have a brief look at the particle system in Unity. The particle system is a very powerful tool that can be used to configure and create a wide variety of effects that can add a lot of polish to your game. In this tutorial, we will be looking at how we can manipulate the particle system to create a simple explosion effect that we can use when an enemy dies."),(0,r.kt)("h2",{id:"the-explosion-effect"},"The Explosion Effect"),(0,r.kt)("p",null,"Let's start by creating a new gameobject called ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," and add a ",(0,r.kt)("inlineCode",{parentName:"p"},"Particle System")," component to it. By default, it'll spawn white circular particles that will fade out over time in a conical shape. Now we need to analyze and think about how we want to achieve the explosion effect."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We want the particles to be orange/red"),(0,r.kt)("li",{parentName:"ul"},"We want the spawn shape to be a sphere (so that it looks like the particles are coming from a single point of origin)"),(0,r.kt)("li",{parentName:"ul"},"We want the particles to be bigger")),(0,r.kt)("p",null,"We can change the color of the particles by changing the ",(0,r.kt)("inlineCode",{parentName:"p"},"Start Color")," property to something orange-ish or switching it to a gradient and setting the colors to fade from orange to red. We can also adjust the alpha value of the color to make the particles fade out and create an interesting effect."),(0,r.kt)("p",null,"We can then change the ",(0,r.kt)("inlineCode",{parentName:"p"},"Shape")," property (under the ",(0,r.kt)("inlineCode",{parentName:"p"},"Shape")," module) to a sphere and adjust the ",(0,r.kt)("inlineCode",{parentName:"p"},"Radius")," property to make the particles spawn from a sphere. I set my radius to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.1"),"."),(0,r.kt)("p",null,"We can then change the ",(0,r.kt)("inlineCode",{parentName:"p"},"Size over Lifetime")," property to make the particles bigger. However, I was taking some creative liberty and switched the material of the particle system (under the ",(0,r.kt)("inlineCode",{parentName:"p"},"Renderer")," module) to ",(0,r.kt)("inlineCode",{parentName:"p"},"Sprites-Default")," which changed the shape of the particles to a square that is fairly large in size. I then changed the ",(0,r.kt)("inlineCode",{parentName:"p"},"Max Particle Size")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"0.35")," to make the particles slightly smaller that the sprite default size."),(0,r.kt)("p",null,"I adjust the ",(0,r.kt)("inlineCode",{parentName:"p"},"Start Lifetime")," to 1 and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Start Speed")," to 1 to make the particles look more like an explosion."),(0,r.kt)("p",null,"The end results look like this:\n",(0,r.kt)("img",{alt:"Explosion VFX",src:a(1180).Z,width:"1227",height:"693"})),(0,r.kt)("h2",{id:"using-the-effect"},"Using the Effect"),(0,r.kt)("p",null,"Now that we have the effect, we must integrate it into our game. We can drag and drop the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," gameobject into our prefabs folder to create a prefab that we can spawn in our game when an enemy dies. I'm going to add a variable called ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," in our ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," script to get a reference to a GemeObject and we will spawn this GameObject when the health reaches 0."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[SerializeField] protected GameObject ExplosionVFX = null;\n\n// in apply damage function\n// if the health drops below zero destroy the object\nif (hp <= 0)\n{\n    // Spawn the explosion effect if available\n    if(ExplosionVFX)\n    {\n        // the explosion effect has a self destruct which will handle destroying itself\n        Instantiate(ExplosionVFX, transform.position, Quaternion.identity);\n    }\n}\n")),(0,r.kt)("p",null,"I'm adding a null check to make sure that the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," is only spawned if it's available. Let's say we don't attach a VFX to the player object, then when the player dies we don't spawn an explosion effect. The last thing we to do is drag and drop the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," prefab into the ",(0,r.kt)("inlineCode",{parentName:"p"},"Explosion VFX")," field in the ",(0,r.kt)("inlineCode",{parentName:"p"},"health")," component of the enemy prefab."),(0,r.kt)("p",null,"Let's test it out and see how it looks. When the enemy dies, we should see an explosion effect. Great! But there's an issue. The explosion effect keeps playing forever and ever. We need to make sure that the effect is destroyed after a certain amount of time."),(0,r.kt)("h3",{id:"self-destruct"},"Self Destruct"),(0,r.kt)("p",null,"We can introduce a new script called ",(0,r.kt)("inlineCode",{parentName:"p"},"SelfDestruct")," that will destroy the gameobject it is attached to after a certain amount of time. By keeping track of float called duration that ticks down, we can accomplish this."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[SerializeField] float duration = 1;\n\nvoid Update()\n{\n    duration -= Time.deltaTime;\n    if(duration <= 0)\n    {\n        Destroy(gameObject);\n    }\n}\n")),(0,r.kt)("p",null,"We can then attach this script to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ExplosionVFX")," prefab and set the duration to 0.5. Now when the enemy dies, the explosion effect will play for 0.5 seconds and then destroy itself."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"The particle system is very powerful and can make the game look a lot more polished. However, using it is less of a science and more of an art. Most of the time, I find myself experimenting with the various values and properties, tweaking them until I get the desired effect. Even though the system might feel a bit overwhelming at first, with a little bit of practice and experimentation, you'll be able to master it in no time. "),(0,r.kt)("h3",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"Why not try to create a trail effect for the projectiles? Or maybe a smoke effect for the player when they take damage? The possibilities are endless."),(0,r.kt)("h2",{id:"final-scripts"},"Final Scripts"),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(o.Z,{value:"SelfDestruct.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using UnityEngine;\n\npublic class SelfDestruct : MonoBehaviour\n{\n    [SerializeField] float duration = 1;\n\n    void Update()\n    {\n        duration -= Time.deltaTime;\n        if(duration <= 0)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n"))),(0,r.kt)(o.Z,{value:"Health.cs",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"using UnityEngine;\n\npublic class Health : MonoBehaviour\n{\n    [SerializeField] protected int hp = 1;\n    [SerializeField] protected GameObject ExplosionVFX = null;\n\n    CameraShake cameraShake = null;\n\n    void Start()\n    {\n        cameraShake = FindObjectOfType<CameraShake>();\n    }\n\n    // Apply damage to the object\n    public void ApplyDamage(int damage)\n    {\n        hp -= damage;\n\n        // apply camera shake as a feedback\n        cameraShake.Shake(0.25f, 0.2f);\n\n        // if the health drops below zero destroy the object\n        if (hp <= 0)\n        {\n            // play the explosion sound effect before destroying the object\n            var audioManager = FindObjectOfType<AudioManager>();\n            audioManager?.PlayExplosion(transform.position);\n\n            // Apply a larger camera shake when the enemy is killed\n            cameraShake.Shake(0.4f, 0.4f);\n\n            // Spawn the explosion effect if available\n            if(ExplosionVFX)\n            {\n                // the explosion effect has a self destruct which will handle destroying itself\n                Instantiate(ExplosionVFX, transform.position, Quaternion.identity);\n            }\n\n            // destroy the object\n            Destroy(gameObject);\n        }\n    }\n\n    // Apply heals to the object\n    public void ApplyHeals(int heals)\n    {\n        // basically reverse damage\n        ApplyDamage(-heals);\n    }\n\n    // Get the health from the health component\n    public int GetHP() \n    {\n        return hp;\n    }\n}\n\n")))))}h.isMDXComponent=!0},1180:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Explosion-23d0a216fc9eb8ad83953219b0010a34.gif"}}]);